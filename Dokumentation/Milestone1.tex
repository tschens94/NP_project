\include{documenthead}
\usepackage{pdfpages}
\usepackage{listings}

\begin{document}

% Add the title of the assignment sheet, your names and your Tutorialgroup here:
\newcommand{\subttl}{\textbf{Milestone 1}}
\newcommand{\StudNameOne}{Jens Heinen (2542182)}
\newcommand{\StudNameTwo}{Lukas Schaal (2539218)}
\newcommand{\StudNameThree}{Christoph Rosenhauer (2549220)}
\include{headline}
\newcommand{\ndt}{Nichtdeterminismus }
Test test test

\begin{itemize}
	\item Anzahl der Threads geregelt über von außern steuerbaren Parameter
	\item Graphen in unterschiedliche Klassen unterteilen
	\item Objekte werden in Oberklasse zusammengefasst 
	\item MP oder SM ? noch zu klären
	\item Notiz: Max Wert von Initialisierung wird nie überschritten!
	\item Unterteilung der Graphstrukur in gröbere "Spalten", die aus mehreren Einzelspalten bestehen
	\item Jede Spalte wird von einem Thread bearbeitet
	
\end{itemize}


\section{Allgemeines \& Überblick}
Die Graphenstruktur wird insgesamt in m gröbere Spalten unterteilt, wobei m als steuerbarer Parameter implementiert werden kann. Zusätz\-lich werden sog. Synchronisationsgrenzen implementiert, die angeben, nach wie vielen Iterationsschritten die Akkumulatoren an den Spaltenübergängen synchronisiert werden. Dieser Parameter soll ebenfalls von außen steuerbar sein. 
%TODO klassennamen einfügen 

Klassenstruktur: 
Ein Graph wird dynamisch aufgebaut. Dafür gibt es eine Klasse \textit{klasse}. Ein Knoten entsteht, sobald sein Wert positiv wird. Die Knoten werden in einer Oberklasse \textit{Oberklasse} zusammengesetzt. Zur spaltenweise Abarbeitung wird es eine Klasse \textit{Column?} geben. Jede Column bekommt nach Erstellung einen Thread zugewiesen, der die Berechnungen in jeder Iteration übernimmt. 

\section{Nebenläufige Probleme}
Hier gehen wir folgenden Weg:
\begin{itemize}
	%TODO Entscheidung MP / SM 
	\item Die Synchronisation soll erfolgen, sobald zwei Spalten in den Fall des Propagierens gelangen \textcolor{red}{\textit{Bedingung hierfür ist was ?}}. Falls diese Bedingung erfüllt ist, werden mitels eines Message Passing  / Shared Memory Konzepts die Daten der Akkumulatoren ausgetauscht. Zyklisches Verhalten bei seltenem Propagieren? Wie handhaben ?
	\item Wie wird die Synchronisationsbedingung i = k (Iterationsstadien unterschiedlicher Spalten) sichergestellt?
	\item Globale / Lokale Konvergenz: alle Threads erreichen ein Maximum an Iterationen ? Alle Spalten bekommen eine eigene Approximationsgrenze ? 
\end{itemize}

\section{Verwendete Datenstrukur}
Als Datenstruktur implementieren wir eine \textit{ArrayList?} deren Elemente einzelne Knoten sind. Jeder Knoten speichert linke und rechte Akkumulatorenfelder.  
%%%%%%%%%%%%%Here-comes-your-document%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
